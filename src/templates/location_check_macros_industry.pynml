<!--!
    Location checks are defined as macros, to use these load the template as an object and call the macro from the macros dict
    e.g. foo.macros[macro_name] where foo has been loaded in a python script or in a chameleon template
-->

<!--! Loop to render the location checks tree -->

<metal:render_tree metal:define-macro="render_tree">
    <tal:location_checks_industry define="location_checks industry.location_checks.get_render_tree(incompatible_industries)" repeat="location_check location_checks">
        <tal:location_check_macro metal:use-macro="location_check.macro" />
    </tal:location_checks_industry>
</metal:render_tree>


<!--! Location check macros -->

<metal:coast_distance metal:define-macro="coast_distance">
    <!--! Check for minimum distance to the coast -->
    switch (FEAT_INDUSTRIES, SELF, ${location_check.switch_entry_point}, location_check_industry_disallow_too_far_from_coast()) {
        1: ${location_check.switch_result};
        return CB_RESULT_LOCATION_DISALLOW;
    }
</metal:coast_distance>


<metal:check_industry_min_distance metal:define-macro="check_industry_min_distance">
    <!--! Check for a minimum distance to another industry type -->
    switch (FEAT_INDUSTRIES, SELF, ${location_check.switch_entry_point},
        location_check_industry_require_min_distance_to_another_industry_type(${location_check.industry_type_numeric_id}, ${location_check.distance})) {
        1: ${location_check.switch_result};
        return CB_RESULT_LOCATION_DISALLOW;
    }
</metal:check_industry_min_distance>


<metal:check_industry_max_distance metal:define-macro="check_industry_max_distance">
    <!--! Check for a minimum distance to another industry type -->
    switch (FEAT_INDUSTRIES, SELF, ${location_check.switch_entry_point},
        location_check_industry_require_max_distance_to_another_industry_type(${location_check.industry_type_numeric_id}, ${location_check.distance})) {
        1: ${location_check.switch_result};
        return CB_RESULT_LOCATION_DISALLOW;
    }
</metal:check_industry_max_distance>


<metal:cluster metal:define-macro="cluster">
    <!--! Check for distance to related industry cluster -->
    switch (FEAT_INDUSTRIES, SELF, ${location_check.switch_entry_point},
        location_check_industry_require_cluster(${location_check.industry_type_numeric_id}, ${location_check.cluster_factor}, ${location_check.max_distance})) {
        1: ${location_check.switch_result};
        return CB_RESULT_LOCATION_DISALLOW;
    }
</metal:cluster>


<metal:town_industry_count metal:define-macro="town_industry_count">
    <!--! Check for count of industry type per town -->
    switch (FEAT_INDUSTRIES, SELF, ${location_check.switch_entry_point},
        location_check_industry_industry_town_count(${location_check.industry_type_numeric_id}, ${location_check.min_count}, ${location_check.max_count}) {
        1: ${location_check.switch_result};
        return CB_RESULT_LOCATION_DISALLOW;
    }
</metal:town_industry_count>


<metal:town_min_population metal:define-macro="town_min_population">
    <!--! Check for count of industry type per town -->
    switch (FEAT_INDUSTRIES, PARENT, ${location_check.switch_entry_point}, population) {
        0..${location_check.town_min_population - 1}: return CB_RESULT_LOCATION_DISALLOW;
        return ${location_check.switch_result};
    }
</metal:town_min_population>


<metal:check_founder metal:define-macro="check_founder">
    <!--!
        Check whether a certain location is suitable for building the industry
        Restrictions apply only to industries funded by the game.
        founder == FOUNDER_GAME means founded by the game, 0 .. 15 are player companies */
    -->
    switch (FEAT_INDUSTRIES, SELF, ${location_check.switch_entry_point}, (
                (extra_callback_info2 == IND_CREATION_FUND) ||
                (extra_callback_info2 == IND_CREATION_PROSPECT)
                )
            ) {
        1: return CB_RESULT_LOCATION_ALLOW;
        ${location_check.switch_result};
    }
</metal:check_founder>


<metal:flour_mill_layouts_by_date metal:define-macro="flour_mill_layouts_by_date">
    <!--!
        Grain Mill restricts layouts by date.
        This could be made more generic if needed.
    -->

    <!--! After 1900, windmills will only be built during map generation, not during gameplay (fake history). -->
    switch (FEAT_INDUSTRIES, SELF, ${industry.id}_brick_layouts_only_check_layout, var[0x86]) {
        3..5: return CB_RESULT_LOCATION_DISALLOW;
        ${location_check.switch_result};
    }
    switch (FEAT_INDUSTRIES, SELF, ${industry.id}_brick_layouts_only, extra_callback_info2) {
        IND_CREATION_GENERATION: ${location_check.switch_result};
        ${industry.id}_brick_layouts_only_check_layout;
    }
    <!--! Before 1870, only windmills will be built. -->
    switch (FEAT_INDUSTRIES, SELF, ${industry.id}_windmill_layout_only, var[0x86]) {
        3..5: ${location_check.switch_result};
        return CB_RESULT_LOCATION_DISALLOW;
    }
    <!--! Both types of layouts can appear between 1870 and 1900.
          Update the docs if changing graphics dates -->
    switch (FEAT_INDUSTRIES, SELF, ${location_check.switch_entry_point}, current_year) {
        0..1869:    ${industry.id}_windmill_layout_only;
        1870..1900: ${location_check.switch_result};
        ${industry.id}_brick_layouts_only;
    }
</metal:flour_mill_layouts_by_date>
