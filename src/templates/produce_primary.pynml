<!--! On arrival of supplies, push the amount to perm storage, then clear from stockpile -->
<tal:economies repeat="economy economies">
    produce (${industry.id}_clear_incoming_cargo_waiting_${economy.numeric_id},
        [
            <tal:subtract repeat="cargo industry.get_accept_cargo_types(economy)">
                <!--! !!! assume just subtracting all for now, don't faff around with remaindered amounts -->
                ${cargo}: incoming_cargo_waiting("${cargo}");
            </tal:subtract>
        ],
        [<!--! no prod in arrival cb -->],
    0)
    switch(FEAT_INDUSTRIES, SELF, ${industry.id}_store_incoming_cargo_waiting_${economy.numeric_id},
        [
            STORE_PERM(
                <tal:store repeat="cargo industry.get_accept_cargo_types(economy)">
                    incoming_cargo_waiting("${cargo}") +
                </tal:store>
                LOAD_PERM(${industry.perm_storage.var_num_supplies_delivered_27}), ${industry.perm_storage.var_num_supplies_delivered_27}),
            <!--! check if each cargo is delivered, and if so, update the last delivery date for it -->
            <tal:input_cargos repeat="input_cargo industry.get_accept_cargo_types(economy)">
                <tal:date_received define="date_received_storage_number getattr(industry.perm_storage, 'date_received_cargo_' + str(repeat.input_cargo.number))">
                STORE_PERM(
                    max(LOAD_PERM(${date_received_storage_number}), (incoming_cargo_waiting("${input_cargo}") > 0) * current_date),
                    ${date_received_storage_number}
                ),
                </tal:date_received>
            </tal:input_cargos>
        ]) {
        ${industry.id}_clear_incoming_cargo_waiting_${economy.numeric_id};
    }

</tal:economies>

switch (FEAT_INDUSTRIES, SELF, ${industry.id}_produce_cargo_arrival, economy) {
    <tal:economies repeat="economy economies">
        ${economy.numeric_id}: ${industry.id}_store_incoming_cargo_waiting_${economy.numeric_id};
    </tal:economies>
}


<!--! On 256 ticks, if supplied, produce extra output cargo at appropriate multiplier -->
<tal:economies repeat="economy economies">
    produce(${industry.id}_produce_256_ticks_economy_${economy.numeric_id},
        [<!--! no accept in 256 cb -->],
        [
            <tal:produce repeat="cargo industry.get_prod_cargo_types(economy)">
                <!--!
                      replicates default ottd prod. algorithm but with supply boost applied as needed
                      note action 0 prod. is not used for primary, prod. cb is used consistently in FIRS, to reduce the number of different prod. methods in use
                    (cargo amount * industry prod level * supply boost as percent) / (default prod level * 100 because boost is percent)
                -->
                ${cargo[0]}: (${cargo[1]} * production_level * LOAD_TEMP(9)) / (16 * 100);
            </tal:produce>
        ],
    0)
</tal:economies>

switch (FEAT_INDUSTRIES, SELF, ${industry.id}_produce_256_ticks_switch_economy, economy) {
<tal:economies repeat="economy economies">
    ${economy.numeric_id}: ${industry.id}_produce_256_ticks_economy_${economy.numeric_id};
</tal:economies>
}

<!--! shift the array of supplies_delivered values one place to the left, and zero the last entry -->
switch(FEAT_INDUSTRIES, SELF, ${industry.id}_produce_256_ticks_shift_supplies_delivered, [
    <tal:shift_supplies repeat="var_num range(1, 27)">
        STORE_PERM(
            LOAD_PERM(${getattr(industry.perm_storage, 'var_num_supplies_delivered_' + str(var_num + 1))}),
            ${getattr(industry.perm_storage, 'var_num_supplies_delivered_' + str(var_num))}
        ),
    </tal:shift_supplies>
    STORE_PERM(0, ${industry.perm_storage.var_num_supplies_delivered_27})
]) {
    return 0;
}

switch(FEAT_INDUSTRIES, SELF, ${industry.id}_produce_256_ticks_total_supplies_delivered, [
    <tal:total_supplies repeat="var_num range(1, 28)">
        LOAD_PERM(
            ${getattr(industry.perm_storage, 'var_num_supplies_delivered_' + str(var_num))}
        )
        ${'+' if not repeat.var_num.end else ''}
    </tal:total_supplies>
    ]) {
    return;
}

switch(FEAT_INDUSTRIES, SELF, ${industry.id}_produce_256_ticks,
        [STORE_TEMP(${industry.id}_produce_256_ticks_total_supplies_delivered(), 8),
        STORE_TEMP((LOAD_TEMP(8) >= (${industry.supply_requirements[2]} * primary_level2_requirement)) ? primary_level2_produced_percent :
                   (LOAD_TEMP(8) >= (${industry.supply_requirements[2]} * primary_level1_requirement)) ? primary_level1_produced_percent : 100, 9),
        STORE_PERM(LOAD_TEMP(9), ${industry.perm_storage.var_current_supplies_prod_factor}),
        ${industry.id}_produce_256_ticks_shift_supplies_delivered()
        ]) {
    ${industry.id}_produce_256_ticks_switch_economy;
}
