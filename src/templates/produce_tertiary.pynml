<!--! Tertiary production behaviour is relatively simple -->

<tal:economies repeat="economy industry.economies_enabled_for_industry">
    <!--! clear any delivered cargo immediately on arrival -->
    produce (${industry.id}_produce_cargo_arrival_economy_${economy.numeric_id},
        [
            <tal:subtract repeat="cargo industry.get_property('accept_cargo_types', economy)">
                ${cargo}: incoming_cargo_waiting("${cargo}");
            </tal:subtract>
        ],
        [<!--! no production when cargo arrives -->],
    0)
    <!--! some tertiaries also produce, assumed to be on a regular interval (256 ticks) -->
    <tal:has_production condition="industry.has_production">
        produce(${industry.id}_production_256_economy_${economy.numeric_id},
            [<!--! no accept in 256 cb -->],
            [
                <tal:produce repeat="cargo industry.get_prod_cargo_types(economy)">
                    <!--!
                          simply replicates default ottd prod. algorithm but in prod. cb, so action 0 prod. properties can be set 0
                          prod. cb is used consistently in FIRS, to reduce the number of different prod. methods in use
                          calculation is (cargo amount * production_level * base_prod_factor) / (default production_level * default base_prod_factor)
                          base_prod_factor is randomised at start (default 16), so that production_level can be used separately for cheats and monthly/random prod changes
                    -->
                    ${cargo[0]}: (${cargo[1]} * production_level * LOAD_PERM(${get_perm_num("base_prod_factor")})) / (16 * 16);
                </tal:produce>
            ],
        0)
    </tal:has_production>
</tal:economies>
<!--! end production behaviour -->

<!--! monthly callback is used to influence town behaviour depending on cargo delivered
      currently included with production behaviour template as it's closely related -->

<tal:proof_of_concept condition="industry.id == 'general_store'">
    switch(FEAT_INDUSTRIES, SELF, ${industry.id}_monthly_prod_change,
        [
            <!--! proof of concept for writing and reading town perm storage from industry -->
            STORE_PERM_TOWN(
                ${get_perm_num("copy_of_industry_town_count_for_debugging")},
                industry_town_count(${industry.numeric_id}) + 1 <!--! seems industry_town_count filters out current instance? -->
            ),
            STORE_PERM_TOWN(
                ${get_perm_num("next_month_happiness_level")},
                33
            ),
            LOAD_PERM_TOWN(${get_perm_num("this_cycle_industry_counter")})
            ==
            industry_town_count(${industry.numeric_id}) + 1
            ?
            (
                STORE_PERM_TOWN(
                    ${get_perm_num("this_cycle_industry_counter")},
                    0
                )
                +
                STORE_PERM_TOWN(
                    ${get_perm_num("current_happiness_level")},
                    LOAD_PERM_TOWN(${get_perm_num("next_month_happiness_level")})
                )
                <!--!+
                STORE_PERM_TOWN(
                    ${get_perm_num("next_month_happiness_level")},
                    0
                )-->
            )
            :
            STORE_PERM_TOWN(
                ${get_perm_num("this_cycle_industry_counter")},
                LOAD_PERM_TOWN(${get_perm_num("this_cycle_industry_counter")}) + 1
            )
            <!--! seem to have to store temp if we want to store the value of the town storage?
                  maybe can't use a procedure as an argument to another parameterised procedure?
                  it's a bug in nml
                  see https://gist.github.com/andythenorth/df51f3b8fa7bce212a87604702fb836c
                  and fix in https://github.com/OpenTTD/nml/pull/227
                  -->
            <!--!
            STORE_PERM_ALT(62, LOAD_PERM_TOWN(${get_perm_num("test")})),
            STORE_TEMP(LOAD_PERM_TOWN(${get_perm_num("test")}), 10),
            STORE_PERM_ALT(63, LOAD_TEMP(10))-->
        ]) {
        return CB_RESULT_IND_PROD_NO_CHANGE;
    }
</tal:proof_of_concept>
